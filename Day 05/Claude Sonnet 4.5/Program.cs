using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Collections.Generic;

class Program
{
    private static readonly string GeneratedBy = "Claude Sonnet 4.5";

    static int Main()
    {
        Console.WriteLine("Advent of Code - Day 05");

        var folder = AppContext.BaseDirectory;
        var projectDir = Directory.GetParent(folder)!.Parent!.Parent!.Parent!.Parent!.FullName;

        var puzzlePath = Path.Combine(projectDir, "puzzle.txt");
        var inputPath = Path.Combine(projectDir, "input.txt");
        var samplePath = Path.Combine(projectDir, "sample.txt");
        var sampleExpectedPath = Path.Combine(projectDir, "sample.expected.txt");

        Console.WriteLine($"Project dir: {projectDir}");

        // `puzzle.txt` is optional. The agent may read it offline to implement the solution,
        // but the running program must not rely on parsing it.
        if (!File.Exists(inputPath))
        {
            Console.WriteLine("ERROR: input.txt not found. Please add your input to input.txt.");
            return 1;
        }

        var inputText = File.ReadAllText(inputPath);
        var sampleText = File.Exists(samplePath) ? File.ReadAllText(samplePath) : string.Empty;
        var sampleExpectedText = File.Exists(sampleExpectedPath) ? File.ReadAllText(sampleExpectedPath) : string.Empty;

        if (GeneratedBy == "REPLACE_WITH_MODEL_NAME")
        {
            Console.WriteLine("ERROR: GeneratedBy placeholder not replaced in Program.cs. Replace with model name used to generate this solution.");
            return 3;
        }

        try
        {            
            // Validate sample if present. The assistant generating the day's folder must extract the example
            // from puzzle.txt into sample.txt and put the expected results into sample.expected.txt.
            if (!string.IsNullOrEmpty(sampleText) || !string.IsNullOrEmpty(sampleExpectedText))
            {
                if (string.IsNullOrEmpty(sampleText) || string.IsNullOrEmpty(sampleExpectedText))
                {
                    Console.WriteLine("ERROR: sample.txt and sample.expected.txt must both be present for validation.");
                    return 4;
                }

                var sampleResult = Solve(sampleText);
                Console.WriteLine("-- Sample Result --");
                Console.WriteLine($"Sample Result: {sampleResult}");

                // Normalize line endings for comparison
                var normalizedExpected = sampleExpectedText.Replace("\r\n", "\n").Trim();
                var normalizedActual = sampleResult.Replace("\r\n", "\n").Trim();
                if (normalizedExpected != normalizedActual)
                {
                    Console.WriteLine("ERROR: Sample result did not match sample.expected.txt");
                    Console.WriteLine("Expected:\n" + normalizedExpected);
                    Console.WriteLine("Actual:\n" + normalizedActual);
                    return 5;
                }
                else
                {
                    Console.WriteLine("Sample validation passed.");
                    Console.WriteLine();
                }
            }

            var sw = Stopwatch.StartNew();
            var result = Solve(inputText);
            sw.Stop();

            Console.WriteLine($"Result:\n{result}");
            Console.WriteLine($"Elapsed: {sw.Elapsed}");
            Console.WriteLine($"Generated by: {GeneratedBy}");

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during solve: {ex}");
            return 2;
        }
    }

    // Example Solve for templating: replace this with day's solver. Returns both Part 1 and Part 2 in a single string.
    // The returned string should contain both results formatted as two lines: "Part 1: <answer>" and "Part 2: <answer>".
    // If Part 2 is not yet available, return "Part 2: Not yet available" as a placeholder.
    static string Solve(string input)
    {
        // Split into two sections by blank line
        var sections = input.Split(new[] { "\r\n\r\n", "\n\n" }, StringSplitOptions.None);
        
        if (sections.Length < 2)
        {
            // Fallback: try to parse line by line
            var allLines = input.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            var ranges = new List<(long start, long end)>();
            var availableIds = new List<long>();
            
            foreach (var line in allLines)
            {
                if (line.Contains('-'))
                {
                    var parts = line.Split('-');
                    if (parts.Length == 2)
                    {
                        ranges.Add((long.Parse(parts[0]), long.Parse(parts[1])));
                    }
                }
                else
                {
                    availableIds.Add(long.Parse(line));
                }
            }
            
            return SolveWithData(ranges, availableIds);
        }
        
        // Parse ranges from first section
        var rangeLines = sections[0].Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        var ranges2 = new List<(long start, long end)>();
        
        foreach (var line in rangeLines)
        {
            var parts = line.Split('-');
            if (parts.Length == 2)
            {
                ranges2.Add((long.Parse(parts[0]), long.Parse(parts[1])));
            }
        }
        
        // Parse available IDs from second section
        var idLines = sections[1].Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        var availableIds2 = new List<long>();
        
        foreach (var line in idLines)
        {
            availableIds2.Add(long.Parse(line));
        }
        
        return SolveWithData(ranges2, availableIds2);
    }
    
    static string SolveWithData(List<(long start, long end)> ranges, List<long> availableIds)
    {
        
        // Part 1: Count how many available IDs are fresh (fall within any range)
        int freshCount = 0;
        foreach (var id in availableIds)
        {
            bool isFresh = ranges.Any(r => id >= r.start && id <= r.end);
            if (isFresh)
            {
                freshCount++;
            }
        }
        
        // Part 2: Count total unique IDs covered by all ranges
        // Merge overlapping ranges to avoid double-counting
        var sortedRanges = ranges.OrderBy(r => r.start).ToList();
        var mergedRanges = new List<(long start, long end)>();
        
        if (sortedRanges.Count > 0)
        {
            var current = sortedRanges[0];
            
            for (int i = 1; i < sortedRanges.Count; i++)
            {
                var next = sortedRanges[i];
                
                // Check if ranges overlap or are adjacent
                if (next.start <= current.end + 1)
                {
                    // Merge by extending the current range
                    current = (current.start, Math.Max(current.end, next.end));
                }
                else
                {
                    // No overlap, add current to merged list and start new range
                    mergedRanges.Add(current);
                    current = next;
                }
            }
            
            // Add the last range
            mergedRanges.Add(current);
        }
        
        // Count total IDs in merged ranges
        long totalFreshIds = 0;
        foreach (var range in mergedRanges)
        {
            totalFreshIds += range.end - range.start + 1;
        }
        
        return $"Part 1: {freshCount}\nPart 2: {totalFreshIds}";
    }
}
