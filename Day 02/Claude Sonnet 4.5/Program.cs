using System;
using System.Diagnostics;
using System.IO;
using System.Linq;

class Program
{
    private static readonly string GeneratedBy = "Claude Sonnet 4.5";

    static int Main()
    {
        Console.WriteLine("Advent of Code - Day 02");

        var folder = AppContext.BaseDirectory;
        var projectDir = Directory.GetParent(folder)!.Parent!.Parent!.Parent!.Parent!.FullName;

        var puzzlePath = Path.Combine(projectDir, "puzzle.txt");
        var inputPath = Path.Combine(projectDir, "input.txt");
        var samplePath = Path.Combine(projectDir, "sample.txt");
        var sampleExpectedPath = Path.Combine(projectDir, "sample.expected.txt");

        Console.WriteLine($"Project dir: {projectDir}");

        // `puzzle.txt` is optional. The agent may read it offline to implement the solution,
        // but the running program must not rely on parsing it.
        if (!File.Exists(inputPath))
        {
            Console.WriteLine("ERROR: input.txt not found. Please add your input to input.txt.");
            return 1;
        }

        var inputText = File.ReadAllText(inputPath);
        var sampleText = File.Exists(samplePath) ? File.ReadAllText(samplePath) : string.Empty;
        var sampleExpectedText = File.Exists(sampleExpectedPath) ? File.ReadAllText(sampleExpectedPath) : string.Empty;

        if (GeneratedBy == "REPLACE_WITH_MODEL_NAME")
        {
            Console.WriteLine("ERROR: GeneratedBy placeholder not replaced in Program.cs. Replace with model name used to generate this solution.");
            return 3;
        }

        try
        {            
            // Validate sample if present. The assistant generating the day's folder must extract the example
            // from puzzle.txt into sample.txt and put the expected results into sample.expected.txt.
            if (!string.IsNullOrEmpty(sampleText) || !string.IsNullOrEmpty(sampleExpectedText))
            {
                if (string.IsNullOrEmpty(sampleText) || string.IsNullOrEmpty(sampleExpectedText))
                {
                    Console.WriteLine("ERROR: sample.txt and sample.expected.txt must both be present for validation.");
                    return 4;
                }

                var sampleResult = Solve(sampleText);
                Console.WriteLine("-- Sample Result --");
                Console.WriteLine($"Sample Result: {sampleResult}");

                // Normalize line endings for comparison
                var normalizedExpected = sampleExpectedText.Replace("\r\n", "\n").Trim();
                var normalizedActual = sampleResult.Replace("\r\n", "\n").Trim();
                if (normalizedExpected != normalizedActual)
                {
                    Console.WriteLine("ERROR: Sample result did not match sample.expected.txt");
                    Console.WriteLine("Expected:\n" + normalizedExpected);
                    Console.WriteLine("Actual:\n" + normalizedActual);
                    return 5;
                }
                else
                {
                    Console.WriteLine("Sample validation passed.");
                    Console.WriteLine();
                }
            }

            var sw = Stopwatch.StartNew();
            var result = Solve(inputText);
            sw.Stop();

            Console.WriteLine($"Result:\n{result}");
            Console.WriteLine($"Elapsed: {sw.Elapsed}");
            Console.WriteLine($"Generated by: {GeneratedBy}");

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during solve: {ex}");
            return 2;
        }
    }

    static string Solve(string input)
    {
        // Parse the comma-separated ranges
        var ranges = input.Trim().Split(',')
            .Select(range => range.Trim())
            .Where(range => !string.IsNullOrWhiteSpace(range))
            .Select(range =>
            {
                var parts = range.Split('-');
                return (Start: long.Parse(parts[0]), End: long.Parse(parts[1]));
            })
            .ToList();

        // Part 1: Find IDs that are some sequence repeated exactly twice
        long part1Sum = 0;
        foreach (var (start, end) in ranges)
        {
            for (long id = start; id <= end; id++)
            {
                if (IsRepeatedExactlyTwice(id))
                {
                    part1Sum += id;
                }
            }
        }

        // Part 2: Find IDs that are some sequence repeated at least twice
        long part2Sum = 0;
        foreach (var (start, end) in ranges)
        {
            for (long id = start; id <= end; id++)
            {
                if (IsRepeatedAtLeastTwice(id))
                {
                    part2Sum += id;
                }
            }
        }

        return $"Part 1: {part1Sum}\nPart 2: {part2Sum}";
    }

    static bool IsRepeatedExactlyTwice(long id)
    {
        var s = id.ToString();
        int len = s.Length;

        // Must be even length to be repeated exactly twice
        if (len % 2 != 0) return false;

        int halfLen = len / 2;
        var firstHalf = s.Substring(0, halfLen);
        var secondHalf = s.Substring(halfLen);

        return firstHalf == secondHalf;
    }

    static bool IsRepeatedAtLeastTwice(long id)
    {
        var s = id.ToString();
        int len = s.Length;

        // Try all possible pattern lengths from 1 to len/2
        for (int patternLen = 1; patternLen <= len / 2; patternLen++)
        {
            // Check if length is divisible by pattern length
            if (len % patternLen != 0) continue;

            int repeatCount = len / patternLen;
            if (repeatCount < 2) continue;

            var pattern = s.Substring(0, patternLen);
            bool allMatch = true;

            for (int i = 1; i < repeatCount; i++)
            {
                var segment = s.Substring(i * patternLen, patternLen);
                if (segment != pattern)
                {
                    allMatch = false;
                    break;
                }
            }

            if (allMatch) return true;
        }

        return false;
    }
}
