using System;
using System.Diagnostics;
using System.IO;
using System.Linq;

class Program
{
    static int Main()
    {
        Console.WriteLine("Advent of Code - Day Template");

        var folder = AppContext.BaseDirectory;
        var projectDir = Directory.GetParent(folder)!.Parent!.Parent!.Parent!.Parent!.FullName;

        var puzzlePath = Path.Combine(projectDir, "puzzle.txt");
        var inputPath = Path.Combine(projectDir, "input.txt");
        var samplePath = Path.Combine(projectDir, "sample.txt");

        Console.WriteLine($"Project dir: {projectDir}");

        // `puzzle.txt` is optional. The agent may read it offline to implement the solution,
        // but the running program must not rely on parsing it.
        if (!File.Exists(inputPath))
        {
            Console.WriteLine("ERROR: input.txt not found. Please add your input to input.txt.");
            return 1;
        }

        var inputText = File.ReadAllText(inputPath);
        var sampleText = File.Exists(samplePath) ? File.ReadAllText(samplePath) : string.Empty;

        // Hard-coded model attribution: agent must replace this string in generated code with the model used.
        const string GeneratedBy = "GPT-5 mini";

        var sw = Stopwatch.StartNew();
        try
        {
            var result = Solve(inputText);
            sw.Stop();

            Console.WriteLine($"Result: {result}");
            Console.WriteLine($"Elapsed: {sw.Elapsed}");
            Console.WriteLine($"Generated by: {GeneratedBy}");

            if (!string.IsNullOrEmpty(sampleText))
            {
                var sampleResult = Solve(sampleText);
                Console.WriteLine("-- Sample Result --");
                Console.WriteLine($"Sample Result: {sampleResult}");
                Console.WriteLine("(Place expected result in sample.expected.txt to validate.)");
            }

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during solve: {ex}");
            return 2;
        }
    }

    // Day 01 solver: implement both parts and return a single formatted result string.
    static string Solve(string input)
    {
        var lines = input.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries).Select(l => l.Trim()).Where(l => l.Length > 0);

        int pos = 50; // dial starts pointing at 50
        long part1 = 0; // count of times dial is at 0 after a rotation
        long part2 = 0; // count of times dial is at 0 during any click (including intermediate)

        foreach (var line in lines)
        {
            var dir = line[0];
            if (line.Length < 2) continue;
            if (!int.TryParse(line.Substring(1), out var dist)) continue;

            // Count how many times we pass or land on 0 during this rotation (part 2)
            if (dir == 'R')
            {
                var first = (100 - pos) % 100;
                if (first == 0) first = 100;
                if (dist >= first) part2 += 1 + (dist - first) / 100;
                pos = (pos + dist) % 100;
            }
            else // 'L'
            {
                var first = pos % 100;
                if (first == 0) first = 100;
                if (dist >= first) part2 += 1 + (dist - first) / 100;
                pos = ((pos - dist) % 100 + 100) % 100;
            }

            if (pos == 0) part1++;
        }

        return $"Part 1: {part1}\nPart 2: {part2}";
    }
}
