using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;

class Program
{
    private static readonly string GeneratedBy = "GPT-5.1-Codex (Preview)";

    static int Main()
    {
        Console.WriteLine("Advent of Code 2025 - Day 06 (GPT-5.1-Codex)");

        var folder = AppContext.BaseDirectory;
        var projectDir = Directory.GetParent(folder)!.Parent!.Parent!.Parent!.Parent!.FullName;

        var inputPath = Path.Combine(projectDir, "input.txt");
        var samplePath = Path.Combine(projectDir, "sample.txt");
        var sampleExpectedPath = Path.Combine(projectDir, "sample.expected.txt");

        Console.WriteLine($"Project dir: {projectDir}");

        if (!File.Exists(inputPath))
        {
            Console.WriteLine("ERROR: input.txt not found. Please add your input to input.txt.");
            return 1;
        }

        var inputText = File.ReadAllText(inputPath);
        var sampleText = File.Exists(samplePath) ? File.ReadAllText(samplePath) : string.Empty;
        var sampleExpectedText = File.Exists(sampleExpectedPath) ? File.ReadAllText(sampleExpectedPath) : string.Empty;

        if (GeneratedBy == "REPLACE_WITH_MODEL_NAME")
        {
            Console.WriteLine("ERROR: GeneratedBy placeholder not replaced in Program.cs. Replace with model name used to generate this solution.");
            return 3;
        }

        try
        {
            if (!string.IsNullOrEmpty(sampleText) || !string.IsNullOrEmpty(sampleExpectedText))
            {
                if (string.IsNullOrEmpty(sampleText) || string.IsNullOrEmpty(sampleExpectedText))
                {
                    Console.WriteLine("ERROR: sample.txt and sample.expected.txt must both be present for validation.");
                    return 4;
                }

                var sampleResult = Solve(sampleText);
                Console.WriteLine("-- Sample Result --");
                Console.WriteLine($"Sample Result: {sampleResult}");

                var normalizedExpected = sampleExpectedText.Replace("\r\n", "\n").Trim();
                var normalizedActual = sampleResult.Replace("\r\n", "\n").Trim();
                if (normalizedExpected != normalizedActual)
                {
                    Console.WriteLine("ERROR: Sample result did not match sample.expected.txt");
                    Console.WriteLine("Expected:\n" + normalizedExpected);
                    Console.WriteLine("Actual:\n" + normalizedActual);
                    return 5;
                }
                else
                {
                    Console.WriteLine("Sample validation passed.");
                    Console.WriteLine();
                }
            }

            var sw = Stopwatch.StartNew();
            var result = Solve(inputText);
            sw.Stop();

            Console.WriteLine($"Result:\n{result}");
            Console.WriteLine($"Elapsed: {sw.Elapsed}");
            Console.WriteLine($"Generated by: {GeneratedBy}");

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during solve: {ex}");
            return 2;
        }
    }

    static string Solve(string input)
    {
        var rows = input.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None).ToList();
        while (rows.Count > 0 && rows[^1].Length == 0)
        {
            rows.RemoveAt(rows.Count - 1);
        }

        if (rows.Count == 0)
        {
            return "Part 1: 0\nPart 2: 0";
        }

        var height = rows.Count;
        var width = rows.Max(line => line.Length);
        var grid = new char[height, width];
        for (int y = 0; y < height; y++)
        {
            var line = rows[y];
            for (int x = 0; x < width; x++)
            {
                grid[y, x] = x < line.Length ? line[x] : ' ';
            }
        }

        var blocks = GetBlocks(grid, height, width);
        var part1 = BigInteger.Zero;
        var part2 = BigInteger.Zero;

        foreach (var block in blocks)
        {
            var numbersDown = ReadNumbersDown(grid, height, block);
            var op = GetOperator(grid, height, block);
            part1 += ApplyOperation(numbersDown, op);

            var numbersByColumn = ReadNumbersByColumn(grid, height, block);
            part2 += ApplyOperation(numbersByColumn, op);
        }

        return $"Part 1: {part1}\nPart 2: {part2}";
    }

    private static List<(int start, int end)> GetBlocks(char[,] grid, int height, int width)
    {
        var blocks = new List<(int start, int end)>();
        var inBlock = false;
        var start = 0;

        for (int x = 0; x < width; x++)
        {
            var columnEmpty = true;
            for (int y = 0; y < height; y++)
            {
                if (grid[y, x] != ' ')
                {
                    columnEmpty = false;
                    break;
                }
            }

            if (!columnEmpty && !inBlock)
            {
                inBlock = true;
                start = x;
            }
            else if (columnEmpty && inBlock)
            {
                blocks.Add((start, x - 1));
                inBlock = false;
            }
        }

        if (inBlock)
        {
            blocks.Add((start, width - 1));
        }

        return blocks;
    }

    private static List<BigInteger> ReadNumbersDown(char[,] grid, int height, (int start, int end) block)
    {
        var operatorRow = height - 1;
        var numbers = new List<BigInteger>();

        for (int y = 0; y < operatorRow; y++)
        {
            var sb = new StringBuilder();
            for (int x = block.start; x <= block.end; x++)
            {
                var ch = grid[y, x];
                if (char.IsDigit(ch))
                {
                    sb.Append(ch);
                }
            }

            if (sb.Length == 0)
            {
                continue;
            }

            numbers.Add(BigInteger.Parse(sb.ToString()));
        }

        if (numbers.Count == 0)
        {
            throw new InvalidOperationException("No numbers found while reading problem vertically.");
        }

        return numbers;
    }

    private static List<BigInteger> ReadNumbersByColumn(char[,] grid, int height, (int start, int end) block)
    {
        var operatorRow = height - 1;
        var numbers = new List<BigInteger>();

        for (int x = block.end; x >= block.start; x--)
        {
            var sb = new StringBuilder();
            for (int y = 0; y < operatorRow; y++)
            {
                var ch = grid[y, x];
                if (char.IsDigit(ch))
                {
                    sb.Append(ch);
                }
            }

            if (sb.Length == 0)
            {
                continue;
            }

            numbers.Add(BigInteger.Parse(sb.ToString()));
        }

        if (numbers.Count == 0)
        {
            throw new InvalidOperationException("No numbers found while reading columns right-to-left.");
        }

        return numbers;
    }

    private static char GetOperator(char[,] grid, int height, (int start, int end) block)
    {
        var operatorRow = height - 1;
        for (int x = block.start; x <= block.end; x++)
        {
            var ch = grid[operatorRow, x];
            if (ch == '+' || ch == '*')
            {
                return ch;
            }
        }

        throw new InvalidOperationException("Operator not found for problem block.");
    }

    private static BigInteger ApplyOperation(List<BigInteger> numbers, char op)
    {
        if (op == '+')
        {
            var sum = BigInteger.Zero;
            foreach (var number in numbers)
            {
                sum += number;
            }

            return sum;
        }

        if (op == '*')
        {
            var product = BigInteger.One;
            foreach (var number in numbers)
            {
                product *= number;
            }

            return product;
        }

        throw new InvalidOperationException($"Unsupported operator '{op}'.");
    }
}
