using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

class Program
{
    private static readonly string GeneratedBy = "Claude Sonnet 4.5";

    static int Main()
    {
        Console.WriteLine("Advent of Code - Day 06");

        var folder = AppContext.BaseDirectory;
        var projectDir = Directory.GetParent(folder)!.Parent!.Parent!.Parent!.Parent!.FullName;

        var puzzlePath = Path.Combine(projectDir, "puzzle.txt");
        var inputPath = Path.Combine(projectDir, "input.txt");
        var samplePath = Path.Combine(projectDir, "sample.txt");
        var sampleExpectedPath = Path.Combine(projectDir, "sample.expected.txt");

        Console.WriteLine($"Project dir: {projectDir}");

        // `puzzle.txt` is optional. The agent may read it offline to implement the solution,
        // but the running program must not rely on parsing it.
        if (!File.Exists(inputPath))
        {
            Console.WriteLine("ERROR: input.txt not found. Please add your input to input.txt.");
            return 1;
        }

        var inputText = File.ReadAllText(inputPath);
        var sampleText = File.Exists(samplePath) ? File.ReadAllText(samplePath) : string.Empty;
        var sampleExpectedText = File.Exists(sampleExpectedPath) ? File.ReadAllText(sampleExpectedPath) : string.Empty;

        if (GeneratedBy == "REPLACE_WITH_MODEL_NAME")
        {
            Console.WriteLine("ERROR: GeneratedBy placeholder not replaced in Program.cs. Replace with model name used to generate this solution.");
            return 3;
        }

        try
        {            
            // Validate sample if present. The assistant generating the day's folder must extract the example
            // from puzzle.txt into sample.txt and put the expected results into sample.expected.txt.
            if (!string.IsNullOrEmpty(sampleText) || !string.IsNullOrEmpty(sampleExpectedText))
            {
                if (string.IsNullOrEmpty(sampleText) || string.IsNullOrEmpty(sampleExpectedText))
                {
                    Console.WriteLine("ERROR: sample.txt and sample.expected.txt must both be present for validation.");
                    return 4;
                }

                var sampleResult = Solve(sampleText);
                Console.WriteLine("-- Sample Result --");
                Console.WriteLine($"Sample Result: {sampleResult}");

                // Normalize line endings for comparison
                var normalizedExpected = sampleExpectedText.Replace("\r\n", "\n").Trim();
                var normalizedActual = sampleResult.Replace("\r\n", "\n").Trim();
                if (normalizedExpected != normalizedActual)
                {
                    Console.WriteLine("ERROR: Sample result did not match sample.expected.txt");
                    Console.WriteLine("Expected:\n" + normalizedExpected);
                    Console.WriteLine("Actual:\n" + normalizedActual);
                    return 5;
                }
                else
                {
                    Console.WriteLine("Sample validation passed.");
                    Console.WriteLine();
                }
            }

            var sw = Stopwatch.StartNew();
            var result = Solve(inputText);
            sw.Stop();

            Console.WriteLine($"Result:\n{result}");
            Console.WriteLine($"Elapsed: {sw.Elapsed}");
            Console.WriteLine($"Generated by: {GeneratedBy}");

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during solve: {ex}");
            return 2;
        }
    }

    static string Solve(string input)
    {
        var lines = input.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        
        // Parse the grid
        // Each problem has numbers vertically arranged with an operator at the bottom
        // Problems are separated by columns of only spaces
        
        long part1 = SolvePart1(lines);
        long part2 = SolvePart2(lines);
        
        return $"Part 1: {part1}\nPart 2: {part2}";
    }

    static long SolvePart1(string[] lines)
    {
        // Part 1: Read vertically (top to bottom), each problem is a column block
        // Numbers are multi-digit values aligned in columns
        // Parse by splitting on whitespace to find number boundaries
        
        int width = lines.Max(l => l.Length);
        
        // Build a 2D grid with proper spacing
        var grid = new List<string>();
        foreach (var line in lines)
        {
            grid.Add(line.PadRight(width));
        }
        
        // Find column boundaries - identify where numbers are
        var problems = new List<(List<long> numbers, char op)>();
        
        int col = 0;
        while (col < width)
        {
            // Skip leading spaces
            while (col < width && IsColumnEmpty(grid, col))
            {
                col++;
            }
            
            if (col >= width) break;
            
            // Find the end of this number block
            int startCol = col;
            while (col < width && !IsColumnEmpty(grid, col))
            {
                col++;
            }
            int endCol = col;
            
            // Extract this problem's numbers and operator
            var numbers = new List<long>();
            char? op = null;
            
            for (int row = 0; row < grid.Count; row++)
            {
                var segment = grid[row].Substring(startCol, endCol - startCol).Trim();
                if (!string.IsNullOrEmpty(segment))
                {
                    if (segment == "*" || segment == "+")
                    {
                        op = segment[0];
                    }
                    else if (long.TryParse(segment, out long num))
                    {
                        numbers.Add(num);
                    }
                }
            }
            
            if (numbers.Count > 0 && op.HasValue)
            {
                problems.Add((numbers, op.Value));
            }
        }
        
        // Calculate result for each problem
        long grandTotal = 0;
        foreach (var (numbers, op) in problems)
        {
            long result = numbers[0];
            for (int i = 1; i < numbers.Count; i++)
            {
                if (op == '*')
                {
                    result *= numbers[i];
                }
                else
                {
                    result += numbers[i];
                }
            }
            grandTotal += result;
        }
        
        return grandTotal;
    }
    
    static bool IsColumnEmpty(List<string> grid, int col)
    {
        foreach (var row in grid)
        {
            if (col < row.Length && row[col] != ' ')
            {
                return false;
            }
        }
        return true;
    }

    static long SolvePart2(string[] lines)
    {
        // Part 2: Read right-to-left, column by column
        // Each column's digits (top to bottom) form one number (most significant digit at top)
        // The last row of each column contains either an operator or space
        // Problems are separated by columns of all spaces
        
        int width = lines.Max(l => l.Length);
        
        // Build a 2D grid with proper spacing
        var grid = new List<string>();
        foreach (var line in lines)
        {
            grid.Add(line.PadRight(width));
        }
        
        var problems = new List<(List<long> numbers, char op)>();
        var currentProblem = new List<long>();
        char? currentOp = null;
        
        // Process columns from right to left
        for (int col = width - 1; col >= 0; col--)
        {
            // Check if this column is all spaces (separator)
            if (IsColumnEmpty(grid, col))
            {
                // End of current problem (if any)
                if (currentProblem.Count > 0 && currentOp.HasValue)
                {
                    problems.Add((new List<long>(currentProblem), currentOp.Value));
                    currentProblem.Clear();
                    currentOp = null;
                }
                continue;
            }
            
            // Read this column top to bottom
            string numStr = "";
            char? op = null;
            
            for (int row = 0; row < grid.Count; row++)
            {
                char c = grid[row][col];
                
                if (row == grid.Count - 1)
                {
                    // Last row - should be operator or space
                    if (c == '*' || c == '+')
                    {
                        op = c;
                    }
                }
                else if (char.IsDigit(c))
                {
                    // Digit - append to form number (most significant at top)
                    numStr += c;
                }
                // Spaces in middle are ignored for number formation
            }
            
            // Add this column's number to the current problem
            if (!string.IsNullOrEmpty(numStr))
            {
                currentProblem.Add(long.Parse(numStr));
            }
            
            // Set operator if found
            if (op.HasValue)
            {
                currentOp = op;
            }
        }
        
        // Don't forget the last problem
        if (currentProblem.Count > 0 && currentOp.HasValue)
        {
            problems.Add((new List<long>(currentProblem), currentOp.Value));
        }
        
        // Calculate result for each problem
        long grandTotal = 0;
        foreach (var (numbers, op) in problems)
        {
            long result = numbers[0];
            for (int i = 1; i < numbers.Count; i++)
            {
                if (op == '*')
                {
                    result *= numbers[i];
                }
                else
                {
                    result += numbers[i];
                }
            }
            grandTotal += result;
        }
        
        return grandTotal;
    }
}
