using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

class Program
{
    private static readonly string GeneratedBy = "Claude Opus 4.5";

    static int Main()
    {
        Console.WriteLine("Advent of Code - Day 04");

        var folder = AppContext.BaseDirectory;
        var projectDir = Directory.GetParent(folder)!.Parent!.Parent!.Parent!.Parent!.FullName;

        var puzzlePath = Path.Combine(projectDir, "puzzle.txt");
        var inputPath = Path.Combine(projectDir, "input.txt");
        var samplePath = Path.Combine(projectDir, "sample.txt");
        var sampleExpectedPath = Path.Combine(projectDir, "sample.expected.txt");

        Console.WriteLine($"Project dir: {projectDir}");

        if (!File.Exists(inputPath))
        {
            Console.WriteLine("ERROR: input.txt not found. Please add your input to input.txt.");
            return 1;
        }

        var inputText = File.ReadAllText(inputPath);
        var sampleText = File.Exists(samplePath) ? File.ReadAllText(samplePath) : string.Empty;
        var sampleExpectedText = File.Exists(sampleExpectedPath) ? File.ReadAllText(sampleExpectedPath) : string.Empty;

        if (GeneratedBy == "REPLACE_WITH_MODEL_NAME")
        {
            Console.WriteLine("ERROR: GeneratedBy placeholder not replaced in Program.cs. Replace with model name used to generate this solution.");
            return 3;
        }

        try
        {
            if (!string.IsNullOrEmpty(sampleText) || !string.IsNullOrEmpty(sampleExpectedText))
            {
                if (string.IsNullOrEmpty(sampleText) || string.IsNullOrEmpty(sampleExpectedText))
                {
                    Console.WriteLine("ERROR: sample.txt and sample.expected.txt must both be present for validation.");
                    return 4;
                }

                var sampleResult = Solve(sampleText);
                Console.WriteLine("-- Sample Result --");
                Console.WriteLine($"Sample Result:\n{sampleResult}");

                var normalizedExpected = sampleExpectedText.Replace("\r\n", "\n").Trim();
                var normalizedActual = sampleResult.Replace("\r\n", "\n").Trim();
                if (normalizedExpected != normalizedActual)
                {
                    Console.WriteLine("ERROR: Sample result did not match sample.expected.txt");
                    Console.WriteLine("Expected:\n" + normalizedExpected);
                    Console.WriteLine("Actual:\n" + normalizedActual);
                    return 5;
                }
                else
                {
                    Console.WriteLine("Sample validation passed.");
                    Console.WriteLine();
                }
            }

            var sw = Stopwatch.StartNew();
            var result = Solve(inputText);
            sw.Stop();

            Console.WriteLine($"Result:\n{result}");
            Console.WriteLine($"Elapsed: {sw.Elapsed}");
            Console.WriteLine($"Generated by: {GeneratedBy}");

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during solve: {ex}");
            return 2;
        }
    }

    static string Solve(string input)
    {
        var lines = input.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        int rows = lines.Length;
        int cols = lines[0].Length;
        
        // Create a mutable grid
        var grid = new char[rows, cols];
        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                grid[r, c] = lines[r][c];
            }
        }

        // Part 1: Count rolls that can be accessed (fewer than 4 adjacent rolls)
        var part1 = CountAccessibleRolls(grid, rows, cols);

        // Part 2: Repeatedly remove accessible rolls until none remain accessible
        int totalRemoved = 0;
        while (true)
        {
            var accessible = GetAccessibleRolls(grid, rows, cols);
            if (accessible.Count == 0)
                break;
            
            // Remove all accessible rolls
            foreach (var (r, c) in accessible)
            {
                grid[r, c] = '.';
            }
            totalRemoved += accessible.Count;
        }

        return $"Part 1: {part1}\nPart 2: {totalRemoved}";
    }

    static int CountAccessibleRolls(char[,] grid, int rows, int cols)
    {
        return GetAccessibleRolls(grid, rows, cols).Count;
    }

    static List<(int r, int c)> GetAccessibleRolls(char[,] grid, int rows, int cols)
    {
        var accessible = new List<(int r, int c)>();
        
        // 8 directions: up, down, left, right, and 4 diagonals
        int[] dr = { -1, -1, -1, 0, 0, 1, 1, 1 };
        int[] dc = { -1, 0, 1, -1, 1, -1, 0, 1 };

        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                if (grid[r, c] != '@')
                    continue;

                // Count adjacent rolls
                int adjacentCount = 0;
                for (int d = 0; d < 8; d++)
                {
                    int nr = r + dr[d];
                    int nc = c + dc[d];
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr, nc] == '@')
                    {
                        adjacentCount++;
                    }
                }

                // Accessible if fewer than 4 adjacent rolls
                if (adjacentCount < 4)
                {
                    accessible.Add((r, c));
                }
            }
        }

        return accessible;
    }
}
