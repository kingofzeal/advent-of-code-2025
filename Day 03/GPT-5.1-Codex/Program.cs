using System;
using System.Diagnostics;
using System.IO;

class Program
{
    private static readonly string GeneratedBy = "GPT-5.1-Codex (Preview)";

    static int Main()
    {
        Console.WriteLine("Advent of Code 2025 - Day 03 (GPT-5.1-Codex)");

        var folder = AppContext.BaseDirectory;
        var projectDir = Directory.GetParent(folder)!.Parent!.Parent!.Parent!.Parent!.FullName;

        var inputPath = Path.Combine(projectDir, "input.txt");
        var samplePath = Path.Combine(projectDir, "sample.txt");
        var sampleExpectedPath = Path.Combine(projectDir, "sample.expected.txt");

        Console.WriteLine($"Project dir: {projectDir}");

        // `puzzle.txt` is optional. The agent may read it offline to implement the solution,
        // but the running program must not rely on parsing it.
        if (!File.Exists(inputPath))
        {
            Console.WriteLine("ERROR: input.txt not found. Please add your input to input.txt.");
            return 1;
        }

        var inputText = File.ReadAllText(inputPath);
        var sampleText = File.Exists(samplePath) ? File.ReadAllText(samplePath) : string.Empty;
        var sampleExpectedText = File.Exists(sampleExpectedPath) ? File.ReadAllText(sampleExpectedPath) : string.Empty;

        if (GeneratedBy == "REPLACE_WITH_MODEL_NAME")
        {
            Console.WriteLine("ERROR: GeneratedBy placeholder not replaced in Program.cs. Replace with model name used to generate this solution.");
            return 3;
        }

        try
        {            
            // Validate sample if present. The assistant generating the day's folder must extract the example
            // from puzzle.txt into sample.txt and put the expected results into sample.expected.txt.
            if (!string.IsNullOrEmpty(sampleText) || !string.IsNullOrEmpty(sampleExpectedText))
            {
                if (string.IsNullOrEmpty(sampleText) || string.IsNullOrEmpty(sampleExpectedText))
                {
                    Console.WriteLine("ERROR: sample.txt and sample.expected.txt must both be present for validation.");
                    return 4;
                }

                var sampleResult = Solve(sampleText);
                Console.WriteLine("-- Sample Result --");
                Console.WriteLine($"Sample Result: {sampleResult}");

                // Normalize line endings for comparison
                var normalizedExpected = sampleExpectedText.Replace("\r\n", "\n").Trim();
                var normalizedActual = sampleResult.Replace("\r\n", "\n").Trim();
                if (normalizedExpected != normalizedActual)
                {
                    Console.WriteLine("ERROR: Sample result did not match sample.expected.txt");
                    Console.WriteLine("Expected:\n" + normalizedExpected);
                    Console.WriteLine("Actual:\n" + normalizedActual);
                    return 5;
                }
                else
                {
                    Console.WriteLine("Sample validation passed.");
                    Console.WriteLine();
                }
            }

            var sw = Stopwatch.StartNew();
            var result = Solve(inputText);
            sw.Stop();

            Console.WriteLine($"Result:\n{result}");
            Console.WriteLine($"Elapsed: {sw.Elapsed}");
            Console.WriteLine($"Generated by: {GeneratedBy}");

            return 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during solve: {ex}");
            return 2;
        }
    }

    static string Solve(string input)
    {
        var lines = input.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        const int part2Digits = 12;
        long part1Total = 0;
        long part2Total = 0;

        foreach (var line in lines)
        {
            var digits = line.AsSpan();
            if (digits.Length < 2)
            {
                throw new InvalidOperationException("Each battery bank must contain at least two batteries for Part 1.");
            }

            part1Total += CalculateBestPair(digits);

            if (digits.Length < part2Digits)
            {
                throw new InvalidOperationException($"Bank '{line}' does not contain the {part2Digits} batteries required for Part 2.");
            }

            part2Total += BuildMaxNumber(digits, part2Digits);
        }

        return $"Part 1: {part1Total}\nPart 2: {part2Total}";
    }

    private static int CalculateBestPair(ReadOnlySpan<char> digits)
    {
        var len = digits.Length;
        var suffixMax = new int[len];
        suffixMax[len - 1] = digits[len - 1] - '0';

        for (int i = len - 2; i >= 0; i--)
        {
            suffixMax[i] = Math.Max(digits[i] - '0', suffixMax[i + 1]);
        }

        var best = 0;
        for (int i = 0; i < len - 1; i++)
        {
            var first = digits[i] - '0';
            var second = suffixMax[i + 1];
            var candidate = first * 10 + second;
            if (candidate > best)
            {
                best = candidate;
            }
        }

        return best;
    }

    private static long BuildMaxNumber(ReadOnlySpan<char> digits, int pickCount)
    {
        var n = digits.Length;
        if (pickCount > n)
        {
            throw new InvalidOperationException("Cannot pick more batteries than are available in the bank.");
        }

        Span<char> chosen = pickCount <= 64 ? stackalloc char[pickCount] : new char[pickCount];
        var start = 0;

        // Slide a selection window and always grab the best digit that still leaves enough digits for the remainder.
        for (int pos = 0; pos < pickCount; pos++)
        {
            var remaining = pickCount - pos;
            var end = n - remaining;
            var bestChar = '0';
            var bestIndex = start;

            for (int i = start; i <= end; i++)
            {
                var c = digits[i];
                if (c > bestChar)
                {
                    bestChar = c;
                    bestIndex = i;
                    if (bestChar == '9')
                    {
                        break;
                    }
                }
            }

            chosen[pos] = bestChar;
            start = bestIndex + 1;
        }

        long value = 0;
        for (int i = 0; i < pickCount; i++)
        {
            value = checked(value * 10 + (chosen[i] - '0'));
        }

        return value;
    }
}
